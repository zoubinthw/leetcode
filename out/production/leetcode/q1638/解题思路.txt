middle
1. 遍历： 分别从s字符串和t字符串的i和j位置开始，从0累加长度k,遇到一处不同的字符diff加1（diff从0开始），当diff > 1, 则不满足条件，进行下一轮查找，每次查找，diff==1 ，最终结果累加1
复杂度：时间(m*n*(min(m,n))), 空间: 1

2. 动态规划
    (1).动态规划, 定义s[i], t[j]分别是字符串s和字符串t中位置i和j处不同的字符
    (2.1)定义dpl[i][j]为从左开始,以s[i],t[j]结尾的子字符串的最长公共字串
    (2.2)定义dpr[i][j]为从右开始,以s[i],t[j]结尾的子字符串的最长公共字串
    (2.3)则由这两组公共字串构成的满足题目条件的字串个数为(dpl[i][j]+1)x(dpr[i][j]+1)
    (3).则找到全部符合条件的s[i], t[j]并计算最长公共字串即可求出答案
