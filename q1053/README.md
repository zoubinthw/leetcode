<h2><a href="https://leetcode.cn/problems/previous-permutation-with-one-swap/submissions/">1053. 交换一次的先前排列</a></h2>
<h3>难度:中等</h3>
<h4>贪心算法</h4>
<p>解题思路：这里要注意字典序的解释：把长度为n的数组看成一个数字，交换后的数组组成的数字在字典序上小于原数组，且最大，意思是：arr[3, 1, 1, 3]
看成数字3113（三千一百一十三），交换后[1, 3, 1, 3]（一千三百一十三）。思路是：从最右边向左边查找，找到第一个升序的值arr[i], 
即：arr[n-1]->arr[i+1]为一个降序子数组，arr[i] > arr[i+1], 找到arr[i]后，再从i+1找到n-1，找到这样的数arr[k], arr[k]是在i+1到n-1中，
小于arr[i]的最大数。</p>
<p>在这里要注意找到i后，找k时，要尽可能使得交换的i值靠左边，满足最大的交换字典序序列这个条件，会有这种条件是如[3, 1, 1, 3], 
此时应该是arr[0]和arr[1]交换，而不是arr[0]和arr[2]交换。</p>
